<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Yi Feng Portfolio</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #0278D5;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #0278D5;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #EFFBFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Yi Feng Portfolio</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="enter" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c0e67d3eb29eab26e9cfb0fc7eb2ae9cc910197b05454656a26491cdee3402ac0715796ef789012b3e3f88a8543ffac4994d056522e4d654f84d3405783cbdfdf7377c6b90ca90b63b1f82d98391c33fe80291f1b50181adea226be37d52e6a127d3839b254af0633746597d3b1f5f1b02551d4b4f9e117ff2f22851a583fce6234c32b73f3796187cbc6997e721733d08a0d648b08bd0d65f0ca2345c37ab0c2769749c6c8455ef59a4bb4fa5a9f25893feb07a150ef92ce8b5cf3f9a015742b152a83969147268722d37415a818cc59f5bd545f57b027d9a689c66e4ba7c8fd7066bed1ab9516dbcea37ed43de1ff6cd38474cb014b76798f8588b0c5a9b6b08507deff4e28c7a7095994a03072fda841df75914f220bec465422c37bac82b7d249c9ddaec54e2d5f62ef48036821f9b37f1b4da871fc5b0232b844b9aa30d243a095b874061b309ba124306b9c7ce2c801bcf01ef7b378fa1425fe8e8d7f2bd95a2f8a06bb0171f4ee55d391703fcacaeff29718668bd1096a8e6d1a7c5c6cc665630107d94e3c4888309bdedc557799fca258aa35399f8609e4c776250c4f6a0422dfc253a25f2a7b6dc1d7f7a9e8cedeadb372f9eb3d05c74cfe407ec9229e0a27d19d64ed32c873b45a9ceab60ea5b3f0be7e250aad2ffb78b41c419bfa1686e00a1ca4577fbefa1ad4607374a706bcbfa52f61eb352f2f2e78d58b0e846d240ee0aea037965b268423e1a0a93fc956bbbd502e01738c382a44286b68e8bef67b5e9dab9b8d2687d8482d967f1c16291994a653e6902c029a573712fa1ce411fac11afd3eb2eb678ae2d1965cf4aacd9ac40f57b5a754383c83bc0779c35c32585147d2edf501033d8a33f19d2ec99767cdbe01d1876d8ffe1eba3fe989a8e1cfdb2bda4b9d89be2134dd07f4c15e9848cb16ef298c6df2fcc05a960f6beed3c8411263e4fd87ebc05984132fde807494a743ae9f04cf770b82c97256a708a35422e86d8f5760cf0d09ad808c8ca76d9caaa641bd1a3287b6fdccb06abe18b5c04e10f3d295a460e4088378f745ed79d5b29de476476e51a736ed2ff8bac37515cbf90c71e640ed6031233c8ef19dc8456940866dc408938042c65c43ceb495fcb7c5a797009e57ec830f6b954de3f7b8b597c22a68524f2e1e36faf38a102f4796c6143997789618e15f34242fa217b51e614105545988285db7b36d7cd1b70dde191c5a5892f36b7b3edb3dc4d965b602e693516e36becd7fd8df0fe9521f74ae091f2a52346b2cc01d224dcb9220046d181dca510652a58f5baa1ff9ef0f402266d81c3ef7656d8c3e11aecebbaa1e9759681944528222b5dbb88cf689cad25f0bbe6764e908ee0dd08a4a3ca9695e3832b81d68161a3e269f1c66645860e574b929c0914ab12c46287d7d34211b969acd0c55263a55ab9f22fa55e5d2caeb29bd4e363226692b0675c07d1041c97722f9a358d36682b73148ce6575e81ca1b5b58b764e16cb563c753950e06382e11c505ffa4a90b0bd6c08272237dede0cf102a2f2ae9077d5895c484000347cfab4234e3d605e9882a9134679a465979c79cc9a33e2d430773eab2e739476a2c6376521fe67f0d07d7c9cf76aa3db8f85b84772905e5d78c176d9ca66855a910b28ba5a2155c9663bc16137dd4c4adbee312420aba08639ee463d7c35afd955f3f339a492670af051f843813538df42ee893458e2f89fc8b2e0fc3718fa30c6cd068364e2e29715c957107fff9ffc7caf7e0903594bd149c4f71043353284f4cc5ea6602370a826c19d4905b46c4f40287bd183bcda323bc8bf330911266ec3701d87df43083a944bcd27bd39d62111d4b737d9635d029e8235a973ac0456e908c9cad7e156b0280029090915d00fda151a321298b3784a0724557c4a906d74a6ffbf18fa0fde4f303478f0f16c550397c5da30d892d9ab5e711b85e822de1e63614de4427efa77494ad4f13625e4fa4796b9c954c6623e1d960e1c7d90dea3e36bc5b9743d1342dc003089a3d08858682ff36a0fcaf84c482f7b5073a880309a0945a47831710cc0e9f7cb297472bc41d68e130cff1827b6c1d48e9e52741c235e4b40a123b75978378015bd8ef170b5395d53bf7417fe7a5d9eacbd1680522cb35decd92a4dcfd7d86ee1efa703a596c1c1edb80ac7cba7e2ce711029ebe8bfb6b6564bbf5adb268e48c09e0b25f2e6579bfe80531c83a914113b585b658696ba239515f939eeefea70e238755658b8513976d1bf2b3f65aaaaf70e054adb898b66e1dcfc5e1db1e44ddb50a94bd787dbca66f1474f57fedb5a9baa25381df5139abf3bd1fa9f87daee274b82e82d0e0ac09a4e772718e9da57db22b90764ee3c7098a18d3b82f893d31e11c3dfeb65c026621e7259bf26ed9d690164b59fa58fb8cfe3062cdb2a4af6b9d96b0638174a88eec21e6e2d0fe5cca4d6cdc07206ec74b32a0bb18ed7b90e9945846656cc2c5f95b19b66f2076d87410de19cf6142d0c60310a87c8fe5c858dafba4d15cad56d0efb4f9ccb6987383fe485615e8ddc3dcda7f9d580599e82625e4c40702cae433c92d041bf34046a7a79111d5940437e33f8870f5cd1430520b48a235d7d2c51729c81f1c03e3d34d614cd3c015d3feb3b6e35bb36153d29f8dd7126448d3df53441d171d132ed517667e9df35d0bae67fea9c4d96b3947ad7eb28656c13aff2b64e94959e66fc8af4425b25a342c10da25b3f34e68e66e383da9ef6a6ea1f481c9d4fb1cd747be50530850bbf94d1eb88c9f4599ed1a4af3ae147df992dfda17a0e0a17d26697f4789acf13d59cd5f9a2fd9e6fac0aba547bea7763b634178294cd61161bf31356268f353c1deb164c12690ecde9f60d0609e2a1914b745bac54fc369b594710235f0349b50f2ce22b5e08cffd4350787714bcc4fdbf8ce64bf15025fd90ce2a56d566fac5c93f8ef736c2b967120068ebd7397ccefefe62b85789ea77249e668eb9796460a164cf828bd0f14f4261ff8d2eaba04357348d8fa34ffa11c7d7373542c69a651e9d915996cf0c15a00726d98f0c69fe1205df8a7af608fdfd33568cfeb0578b49a8f282bf53cc0fd5ba79971eb5814b0ecc83ae40b29c01bcb458854483d6657ecceffa1d1c756087d22949a839eb7ae0734a0e488ecfdc16221f87f6d5bb236328644826092c30d9b2bdea6676460326d40a7bbbe8a0241273997905719d175d27639f388d033f19c22dd6d8154c77d666494a8d65430f7aa77b1bf732a25981433f8e166c4b47cfadfda3a770744a2a4025467503f52a5a8a457f07991de02ea19dbe8e08c46e08ef3f57a2ab0bb4803976ad854ec9af5b7a4c29dd0d98000d759e48b03f0b536bf42b5d3b70e15bc5648430194688c23f38649a6ca72214056b051a82bde0c9df31c2271a295bf05a0649d02e3aa6db60eff2cb232891d41e76c2c1ddde564114dd6535447ed9ae84890438e828e41ac18e89ef7cea3a985a4d49b7d8673d4d81b93df35f0d643a4ff40212568f485f39a3e05361d9e7e476995576f3068e68559e86981012106722a4d477d5ce8d950b7b522198713a581ebbe8cc5c1d65dc3d193f255289ba6945d0634fc6d998cdbc4968d369622c4a25939bee1fb4f4d2db39f2770cf8d856042c135967df6e46154a6882077e671f68f22bf71174c4645133589f8eac8172221400311e448312d43c5e973ffad86d1ed6d044d46975221eafab66cf57b5b010f1065fc3a3cc0c46779bfe603b208816cc9ae0d2beb200c6fe08dd2bf42e61badd9525b6264319b137cdf237ad2ac90b05fb205b7960c32c0f55650404823d4e542496a4fff500c70d77a7ff07258e4a8f61db02c1bb1e923c337523b0eef757201c7cf6125a645647a159954cd0cc728ec73a8ac013e977cda1991fa723b6836d51a69a43965ea6dd59741d702c840df3f550f829c51503f3a679613f0270ae0bf8522020a4186651cd7aabf096caeb237ff92bc1ca05255120e28be721853fdd7593ae5222ad5c5e7272927ec1de443d607b24e1d12a7148c4be5c038cb78d53203f2dda939ba0f33cc5bafe5af576c6dbdcc03e7d8e7d044cd3b07390ce3ff575055c686ccebfce25a644ebdaaf214c2ea941e035527ce670f201ca193b1b31e223bfad56df5ca4fb2d186cd6cdf82508aa9034ff1ae5f5992bde3e606a8c5387dc5d20d25a8895729ed55d9dd4bdf02688ca8bbc30bd7826656eab47e95ea80795770238f92936346b0f81272751d081f13eb8e26d17fa9c403578b910c21d2c135abf8fec884585dba021104dba1cfacdec8a8cd9c0adc471d3fe38192d87ce2bcd4e68f8adeeed64c1e9d296795163f514de0760978ee9b55a5d10f6d895eda0a4172369ead656ab0a384dbaa358414098357cfd712c01af975b675e8ffc1f505b800086fe1ccbc696f52d6b648d186228711352140b740ba39c7849fd5fe809887e9174a2dacc5c553928a4b248eb01129354271d64107ab61fffed1e0d9fd49ea3e0286ec7ce2ed9fedefc3f137e8b3febd1422c768c6c0c48dec4582e1168df425f8f21a50b914238d807d6af3cfed32b17f209ee52cdbdd459c88b2925ffdb81ee6eaba54ef645d85e4670f88c174e0ffc31e2d9f4f5d23afd040fd60cabb86d193437c4771a0e31d658802b98a66dd784eeae9702493c321d6c21d8e04bdf27e596809cd52e83f54f394a921333f5f86e9e70e7e009f38fc513b94497479caeebc03be4a9b8331039118b960e8a3b9d192f61af2a30882dd4175e393278cd75f9efc0ebabf287d84f0ec1d67870ee7c449b23c2ecb0235e8194d1fc0319ec944a11c992a6087c980899f472f4e2c3f7d16594c5bd0562e15d9d84fdb29043c0f8f0d87f0e416d628edc82df8e23fb3f93f1f49bc33798d92c5923f1f6f627e818814bc8fca0140631afb672ea3ff1d6661938399bfe7c3af02e677d4edcc232066300127ad8209e5b2005ec4535f20f4c515aa6cbf50f5fac8b590fa4cec01b511bace3b75f6b7d4d8ad4bda21657511c3a939320dcd8984983fb377d172838c99b2efccd59d9088356c83813b3d3cdb724ab15e77d0f14418147987146a659e9c6ba026f1fc9456c901867fa8cbb455445d0787153cd21dcce2a4509b486f921d824ca049dfbb84d1427d2b42e74cf628dc603fe28ef253563120d365749d8b37ee70881c68282aea308d2dd5b1373a2bd61aef16b4c8d5f313a45c4746a83f1986ef8d42f6bde1e59c679f556ec86cfb8f58f697ab6c25bc38feb54643fd94259acee06416d2c36774ca71207940c6c32f1320456880146696ee4a32b6e7fb82f77921158a33dcca3b4c21e31e153f601f2b6985f3a7eafb39639f5d5b34c2870381dd981cf512df4579750bddb5e56c303e438ed33dd156c21920a4f0f95d583911c077e6f655fbd9e41c7857d8e04e5d3681ba36c175063ea34a1b9e328f270cca3bbcef0069205a964ca9005bb0f2fac503234fcf7216aa026e96f5d5df7c77dd93c1ab5ed797af3fed7e1de5bd39023b7e7335fd6daa44e5904625893541359c12201bb68d8558d3762b925f5600e7eebb4458b16754663585d302144258ac08b4cc6468cadce826856fa1cfc5dd53ea7beb030d60c1c02cf4aaac37a4ca9bc89dda17686de8b7a6d31934b62aa4b2ee518e33e202ea7bf32069e5381540b0c2dd47f0e05e8dcf3b1005c661c9f60dd9d0b7362a6b8c49548868ed1e8a55b74e8801759f170d6082aab5404188cbd9f9df04b7904e4be7bc690c581f2d91795630e053468665ba0e60a3bc6f6483ebd949acaffd1e1e6cd8db257a06ef2649fa98ec5c6e72e5cee5e89a8ebaf21b3b64b05061c5cddc7fac25ee5dce51918c64b5fe4b277605072e319d7c4d1f47a7c5a6b9705f00be42943774136259d7c168e3514c9742371b4a37559203ece13a6a99d3c5d140d88cf7b6005ea383c18f61852f0c875ef47a45ce719bcd31494693a1ff738d82717bf5cf6ec1e5e2464eddf034f0e7e8771abc88ac5ffefe3507fd24dec3b09badffa549f22d5624edac550e89831cf6636fae98297b66cfab823d678938e2bccd7fa15febaa444487de10cbae9e3641339a29e3cfdea14e148d0acdf1df83a6dc3cb5fc136d0ed39db41b1e9129c50f6340c28eb86242d9b42f2c9a92f827e5dde5602602bae5122efdf9e63b1c291003a81d3e3072635dad4948290cf1dcccba56fc71e54264fb7ec2b42acdc6ec3167639e169fdd32f99ebb00f6729c7d986b0c4f83b3e680faedf56d89c0cdc410856e8fef2c49f5c36205598b94df8e7bbbf06aab2d1cf9e6088fd1c0fbdb6b198b026a45052e4fa33755b908afcfbacfa2cb5db4b4a612f6c5ba1e615c3e2e84935aa09bed00558524f3ae052883fb1cc39da0d1c81c51b9aa73f458f206c27197969426d7c41439e01f07296c4db667ffe9590d6f3b841cf7089e05f50a4fb84a6358b6ec0296e8776dacb70ac21f712f99a7af549f01277fec239ad76e3ebfd5108bac34111e3ff2540c4f4a71e54cb649b8f3a3fceda25f56e568d10d3d4e0c3f2305c59f0c7bb155f6cf9f5dcd86bb6fe9d5cc1e86ef53f16c063e3d4a128f55c6c58488cfca331ddbab222c65095bfd24c59f9a0185877fcf10ab09f42519c288306ac6201c13eeaf35c1fc4cc5db1bc82ec2ab1252229523ebef67e703c611ff15c40f085fd16d7628937ef92df483524bb29c1b64a155761ee0083784d9119a799831a3c254e0a98d0a835084e3793c38da0f71de94ead299b0104e6b229e662708a4ad896fcf3c90e43cb2cf873885db0c5748dcd3567773b2f29115a22c9e91e51d9073b55d95f16053e45d154319ab6b6b6154ab4e32c0737ed79bd022bb0f5d2d6752ba6d057e127d0c685b5fc9c4322aab05ad7efaa2cc35c19560a7ec99c86457cbaa2d89ac54a9fbf591f494e7b3f7ddd27f1bedbb00e2324bf19afa26150bba6497b2c46a9198b6b77912b3f9eccb89386545272041b93a5842bbffc5d1511bb0b0d04ec92a4a6c528bf8dda5d7916801b8bc60857ef7eccc43e64f411071e91e5c4fff738f358df5d3d9e8e9f6ef630a3a8ba1f581f525c1562e18be223495ef2c00df63438779e5e736a92d75659b67fb0610dcf031d354cd12e21674e1f0abf3f759339c42b6fe7afc317c307ffa6d180809811ac76d1c2935ca55327308a1470131de8c036d19a8bf962050e06398f67e7089e698cd81227690d38aa10a345c5d6b758bb5cdfcf39bc0c0c4cf9f5a6cc6c20a49b74984bce21ff0c9652ae1502042e82670423c553dbfbe950d6147a0b25fd79aaca1e18bfe58f729f1117d9dc96671910dcf128a4177e2cfb48841d7c527ea15a422233b921731a10e6978e2a0a41818bc1fe40b6acfd86787f270a5037dd6e7e7f1acf917d3f20ed3e04553d96994b2aa631718d187d214f17bc65c0c439cd8bc845239667376469af32951b23bfe5fd17fb30e6590c297fe3ecb0b617ee5d72971b69ea633ba7960d93c7f0270d52657f34e1aea7c6f8a7dad6af695207d08b495b0c133980c2b36bb86c4ca4b753e35dc4b91f88396fe10b97b3323b291e8691e1f2bd3b3b3ee947734a21e28928fddfd332f05bc8fabe4b6d464afb3184c415709381beb4ddf8e70f771b6f799f0d99296c2c85aceccd7ad29a70e19ad85efb3a30fb04fa391479bf6cf2997acb04fed9011f652d6007d66606dbe67f0f0091ec75ae8eefb5e1632c75a04a749596fad2215361a1c50e363f82b6212b041355aeabcfa8b1c6b4662081fb3ff4bd533f31e6a95ec62a4fc0ceda40cbbd5e510eecc5fedd0ab843fce1bcb3ede7f89fd61841dd05bd9b3deeb5378ae198d8811b1457da2d000c7fb354f7aacddc66bcfecdc95ee28a31a16b6b835f4254bb294f151ee94e8976b3010382cdc5eb4c7b4d31dfeeffd66eec5a2aeda8be9e4fe287dec6c6bab59a3b906f6b5e434d29265e0b236f03663c96ce35b5e95bce2752e9f017571cf7d6cd95ea660127e6423bc8d4c51a9fbae37af26af639f2e95b3c94ef7c1f9a0c5fda01343d8bc1214f8958e89fa472a80bc530bc344b84850fee064033170dfecccd9a40926f9cca759c08a68065ea8fee2fae1540cb38fd44c5c998b68366ac235e29949370bd77b4afbea4ea428610b62b2f16271b713b0edfea681cf83cf87abeebe35abd74dd0f4df73ee39cf727e439d3175fe13651601f12b8efb5d513b7af17f0ea2e50c0152795189098446bbbe04c362db1f06f0823f16337c9454239358feb04137e69932b78c895b3b6edefddf9d538ef0bed5ca085560a7392461096143a7f0d385527a4cc5c4888706a7fa450a8d3e08785f68a70f2814650824179aaa19be24d2379f5b47bc827b0051be5a4a2ce6e61e2eb5ec8cc6ea412c39cf57a1adf3131305d41788c1290e217de1fa9d5570e7f7e9aa5a553406e3e7546d381a03a4b8396b8a48d4e816938a85288e6e5e2db2c4f97ce3ffc6439fa896c0f732d98318b335317ef722eb822f8bb50255183e04caec9a87581b35110fd835d1b083bb22fe357e982dce450a57aaeb1b159814275f290d7805ebf512c016e5ddc71647267ee8ca584bc1720283ad84fd21b6ea73455796da58e3b8588e0da353ed1ed43037c178c0083f1d72b9b1fea156fb92df71f9e59b188bafa2bc265c47477891e88a3f1950235c44c43b5f952112ffde8b8fe14e407714d94c5f39c44034e94937284c20503f4982dc9e72b514550ed1b51b0af0684623f0a1c5e995e94a60577771b77f20295181aeb42b35c1d32bebb41160c4b1cccaf177d5b58ab4c916095f4f5eee1515fa5874831a40bef1079e2fc55e02c605a7fca738780704cae56e1e0dab5db191561ff2cb20f04c7cb286daa3414dedda9bea9cf59c3e97d75b35a7b17bf4a5f160d65e77440e07d64ef08523fbce03fcca5b25766e9423975c2dfa1638fd78a259d1fb54c0cb066ecd9befa12160a6cf387ffbe12f4d179e4267c59f24fe69ab81b67292278ffd0dd450f4329d6b48fe9348441bab2cfaf71633ea736093ba1e7f7d5e8d0a85c772a9d794bb68622db650bdadcc1d7cd46c7d2444c2e217a2e7b297f937a3ef1621613cd965842525c030d15e35f6abc2f837690da818b1eafb96ab44ecf1ded55a29e748c6a0426401eb801c53daee3c3be4d6a9952d3ca2a0b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb361cd9e6260d741cc7abedab461fe6"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
