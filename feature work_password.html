<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #0278D5;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #0278D5;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #EFFBFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="enter" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9761a3f067e52e8e42b56a2a67dcb0eef75fb6d6168ea6c1d7ba8bffb2550f8d79bfc8a51049ae9912de6820e8351ed5a9de3a39b812955c5bcd9b34f04af1766a595de4dd8a690bb3956c1eb0fc855d258518592102f40db9353880e911b1e839545832f5ad8ce6d6d0eee67848a04e03a8f1016b436042564bee1d130096d5e77dc95cb6189a5bb1d62058c2c5bbc2847b6ad6cb439b4cb734a9a7a14b2a464c22316e3c76dd38cea91e1503d3a0b4dfb505e2fe78296f0f0564702c117209b3f7017af60db59716941b41de8f23fef27fb26542c8425c1bf1777421bfbb3b5a9ae8a1491fd6d654b2221cd978283d5192fbe6178ef19ecad3573f28da6d490e822d745c9e2a45b847542a2d6eb6053db1c53ff4877ee058ee74d47e0818e86960acf745ad3d4427824ca2d55a6457f070a20459970f2e55db64c12313229aca55e50ee10f5064fd63d83f0351e400f544be33477c2f589f5fe52d02b22218dd4442c201416b99da47fdaecb99f2f8e7bb23d3a7a8ba08f8077397fec98e79874da517d11228677c5282f7ad079145ba03ab37f11c7b5c364981c87b298ac0d5cb866f7ead71afbb8b6da54233e622b5ca48586299ab014afa4e07f25a3e31deed4573525589ade8fae5594552b6b14f499c56d14ac293214cfa34a677741b8ffbc9d432630e30917fb71849d51649bc35742fb12f56db72a92ce9690b8238c27c2546aa3f996c9ca27b628fef2310111094a26ec2817bf9cf5731a9a318839846c9d6b34dd10ab71eb164d8801f8a539a87de42cc881f9ae4dc1eb4dbd1d8d2cd00160520b33df498bd8219fbc99fcd997990043bda9e43f3b0affb90bedb86ee8990daf3b9c86c992014782d195233f1c6ffaea46c275eb102399de1006e107205c2252a7e825fd6135eaae4e2932c7afb8bbd79c9a8b4c6089f67e970145a74adb4d90b56a35d021fd2ef23f2e6c1bd09f2660fbd16f9d8f50bcf8b7c0382c92891afde6822b0f047d8dfe7e6e5a6bc196782934f633c2e5a4ccd6f7e9755670f12c7962ad4db4bf2be22a155e72b9f039b33c75a57a861801ac61ecbb840465654cb8e9d742fb407bec43c3d5b30db3e28ac04367e6155dd63d20f094a6ff1a0c2200ba1a0c8087fdf9129c80356e28cac9245c1e62865e93ad2c09e59ef790903e95573f2a478d58c00e466bd2c22d874c8df5bcbbbaffab27f616033753532eb69792874ed92e19c68207a532f6128791ed5c682e2587f78342ba6bb7fe5c17b6e099d870968ff6511eab2aa0c7d85d53bccd04181e5fb80a26d4358809e671ce83aeba9075c636a34a900533f39986683bdeac0c5f30913eb4ed98f25078587036a13a517710152258aaae3cd30d3a369c344cfe25c172bbbd693b210512cd3a570b8fe053338682a2dd41e20843750d9d3eb8a14fbe6c39f93d87a02cbb9fcc68137042706dc6d56f9d4fb7e53ce9f8b561ad4a40067f4f234858c62c075059272d10ae025192dec6c8bb4aba7672f34761473b36b74169a27300f1c82b48d8ae5ba0a4c6e2871737f248a247211d6a464e2a552927e9e2a405beb1a793e82ddd5d93e5f18ce653aae9806e9113a98922d645092091475ac19f269a6f3484e291038e41f0804e1a65bdd3497390f7c4b846b3cb53579e7afed9689e2e2924ce0bc9f7a4a49d4ee195eb996432fbb1a77a7627c1288abb2242fc61877d6a30ff85dece2b50806af88fba1464b12ff5b62db38a08c1cf1fda6dcf95efebffc944cd119bf8ca066ce59dfc7f17a1b4d1b0ae2be68238874c81100bcf70c2d7ee24dc25a4ecc98cb3e5fa38d7b0218aa3e48ffeafa12c3f9256f6ab63844a9103b339b5e8c16c2fd5382981ca5d0f397f34020f674ca45c15d1e833d3d04ff8892194d799c146631751bc076122fa3cb5ff18b75919cc12acc8a5212ab6c6b2b5543f00ca0c7b14728323f5203911e9977500e1a5187ec1a4d35c1c68d1ebb6eb2b0f3d443c292845fec7faed24d4e26ec1cf651bff0a5abaaad23dc7271f9e2f17e42817a34eb238778af15f3a904a1bd224ec72164f5c59dc7f339504b454268af09ab3b4ad34346111147cd6cff8d0ba868fe096e327f4d2ca69b097da9483a3ff74879909e41c308fe05690c67a94b629a56d5fc786a5f1aa917395c668ee8affcbb356689cf0e12f9ccc21e72f6622cb383ddf9f97b6d563d5deb159dd95fc96c7cecf5b77e2d4f32f3303667ef6b3edf6860766ad4efee77094480351aec13bc4209db206f23bbd739b91a86b6899fd4817fec581ec202576ef7f84a2c156dbbc44fc94ed13638363fbd86c4442fde8a947ef49ff4bacfbb2872891f080d01b604f46cc023c49b228162bcdeb5b5538e95371e50caba9c380e42088f51564e5c89067ecfc3d6fa4f10173e056bdd113c83ab617700bb5c10ac8e3d704295e5df46c620ffbde08c7512a9970a396843e00fc7ad408e5688c4f851a2599baf3daa184e6d0b7c8685c1ccf41293e725b31d1c17058b4831c3812252b29acf16d0a78ea10cdffc979cb54b7329462c045a86a4c1b4aea65d40e6573339d3fb01c1e4d11796c7dc2e79dc9726a6e8ec52bb31e9117446abb04d9b15548b667517e5427de89daa0ad3fcda834d3e6ecb2324fb81acfa6561397d4dd84b850dc9bb3a89cb3bc030db3c7988dcab3256f2c48d1198055f4e18c91ca8db39afaed2a4d163695a4c852a342aeaf356272481b9d8e03fe9f7fbf07a5b549f914a5bf224b9c8fb039d5ee07562fa0f39be1d1be4e7af29d70979b709b2e876803df3fe557c1c2de6d8b3cafc1888e93efc70bde4e138d29e1fec949ab2c93e94595556817603e91dd9283ebb1abb5a56aa579cf95a9093101f893f685e7bcff5e6786f5cd2b5127712925e25832a87a35a7ba182360b751dee1113d73c45d5cdea137349878b48ace39aa1e969d1248838613039eb66283178d78e6c129ec45ae13e4acd6c8071ecd89cfa549d27d32680e40de31b0e0ab4c7c2150bbc5d68f45d0b6aacf614cded145fd7244794e5404c9977028a3567dc661c6970259abbbf9673fca981ac603f9922f1bd29855f9fcce7275ecfcb515b0b518c8b1c87864e04ba13369fc7ff0da21f96bff249388ade983561be7fd45ce3d2d55d84b83511cfc05c8c7d22cd632372e416a7d53e610879c2a7ebd3552cbff0465e4e7c30b5ef518563fba113b1f3bfce81aee147acd2af4bacd64b46e06126ce7e1b8be3c2f43ea9526224a85aa1ba20dfbb3463c43d02b00dde670c8b1660fc67cb3a0bed4e245eb2b005e7450f93096fc9329da8b684682ddb7684eff8c885826e10ab771bbe0de13385a813cde55c5dcce18804f8309afde6f30c2e5c16ee0219c01d3ea95bc052d291a80e9eccca56695305de7182492a88f0c52fe3797a72ebe66df5ed03cdc8ea4e9d856d0143910518d75c6c47f0e77e711df422ec4754dff6b47be12ae9fc92b197398c443446a2f6714538c5cf1e4df6fd63ea269edcf5847c95a491a202f5b7a10dd075be66477d2d1e272c159c790539087a5b9f83314a1bec5c6c227eb531877d6621bf6d5eee6a1f7dcc98b247386d0cefc5bd1db6d37ae99606f90ad8bd492d68599186c4adcee4f6dca3027cc05446ef8dd3fbb2a5d66bb9561fc469143fcd4485c1e50ad164b54b5a5bf5ec23754da7fbb0748fe6f97017662d2fd3708a9ab5fd53fd549b42ff1116cf49f144cf945735b08a08151daebb71bea96d797d5434606e84f4438ce4734a3fbfb1f777832c067e66a86d0e0cdb21ad224b4e73ec871b28745393f023904eaa723ecfb574f807feff433cf6dab94fef3984e3384dcf35be80c978437bc70a64872dd1d8f9c474edb67f3578d4dd5bf129f53847f85f54e1e21a173f6ce4d7ad52e4eb9edebbae627aed3f0a3bd197b37de9046fef9e3a066d192bcd103b14576c6df6104b3f4534d678e2e9d5df9ea34733cb526e16d14ab5198c380e4cd21202aabb5d0bff21f41c749eeb19f36ea54185a7a71a09db1c1215924a866cb244b1edc119c7ba6124b60ddf9ff2d168a412620744aca3e2a48fccd316ff3cf78c77bc727745bad961e11dd6736a33431076f97ba32b2eec4eae1695575003f078d18d781f25ab70d3ac62494c214d94e3c0e58ec52d1b630d567565b805304e94d2e7de7c1c6bf6359a5a4c4710a3749c0529b5af9068f3b62aed3a7aeee07b653cf51c6a35c27def85d60e7aa0278e4ffb9dfd79243667190fa341b488dab1ebac76ee96088405d4be365fcbe955ee621baa5452613f73be94846b74d8a1275b33aee82f3031ee73fe4768297ef7771b77c3e681c1cf32d53b2378da07968ef5b163a57627fdecfb8ed8f878e465ef5e0287425513a7d8e93f9d46c678c93f58f3e5b4e1638e2749db9173952834db2ded5c8020e74651f2142dc4e28aaa1a3d31c1fb7ab469d8c8539bf54f9fbc4b4613c63f870056c18b8ca94f86fe2bd9047e46547851d444693fa764c3ef146fbe73c1021425a1c9225e507010151ca2edf76f18220b7c3faf023346fc8598340b0824a488685eaf438bfe40b4138a065beba39ecc711b72ffa1639950e91a86d691da2a62280593bbf6872b6a359abd3251c6dc805a7faa1b835136b00c530062e24af5b8b4d9a3eadb67c8315b175124d9b0d3458e5b31ffcdcfe54c0c8a4348464381f8c47951e0fb9c7b4cbf6a3dd608fd29d5b4a63eae80e09ca7adda699216fe63b7751dd4db4ac5ed26672f84a928bda4fc90cf9f8dea7d789080661474d4c3d1c8f10fecbe4d12767c13aba1b36a1894dced86a367b1022b9e68dc79377d0c2a692b7126ffc63d58f18e59b53aa91dff5baf0cf0d8ab5c5ff7c4f75d39cb711315411eefb0945d81bb013426760d27f34ae441cd7af2e0db7806e0b6bcce698395edf17e25c9eb190b6f7d103977b50db03cf3beb36cf609a888d55d2f66c68e6b4f35b321612aaf142431905cb2f08088d5f8788fc7f84625c17a662d73341366a5a03a457fe95cb9454bdba3e75807c5fabf4f9188b242c43a25a905352be4cdc3047a23d3bee8d4e2bc12a70e6407ddac642d87cbabed3522f98181e69edba5dddeb7027bc3c214fd3aa117c004079bbfa72d09bc84b3aac3d265302011ea77d11dfb751f49a0ff14ab1536797321c16f7dbaa6ce38618065e5581441545a37e6ac0971446197803657b3f6ee99855b22943b427b29ca3485d42712a13a3f9d24c343eb6d54b0f39bff10cd8b79bea485d3e6b77eaa0143093fb2ac51bc5fc9dfe808a6a8d33b0e2948041bf782034006194623d1a0fd438182c5a71f94c9fb844209e1fcd96481848693af9a98b02fc77c556e3453abaf536ef6c81117a2390df648e9f343ee64aaac34d3beb99d04dd75ee9725613fbc2e51b86059c87cfc533d577a9598e0d451a0b3116cada6968c50789ab39580433c75515ca68c473c0691b580bc8e3e1f33d280973c366a44aa412e2b2e9a7922752f5570fe0eb570cfe9e95222146b80de3d47475b400322b99a5fd12ec8ed08a959d35a128658e5049c783d2a295960858723231525d76c25d532e65a0cd426dc1bd6f1ab8c7da0edee41c6daf4c075fc54a4d06866d2a6cea873a43df0e938c7b12cbb0846e345aaa86c0ebd9734abe13d9b8ec8c00ae23ca7788cdb0ab4febf29df1ea11192920a4905f084a8c9789d1ff559baf95fb9907d41dd3910accfd5595d1daf23bff6d037d5135b2e84c21b7d40cbad1d3900aeffd90ec75dc3e4998ea85d0486be4e81e07e8f6b24ae9a04c8ac4ecfd24555e651c46ee3b9af396380dd666bb80bb4432e2d790c50d63bb99d7bb4df678f86e8592fe6e4d73c278e4060504b5cc3ca0dedd6fc3e565c8833038f86f15ecb979188db7ec269bbd5ce647c9997178201db02de8de6debf971b1605b873eb3308f47674d38c24dfa882b3995df504b5816c83bc806d5f76e771de044166599b1e95525372ef71d41f823f84b365962963a7c54cea82651db5ef3f3d2a10542bd854d487acdd357f135b6003b78d30684a09262ca193e4bc81ef0d84922f1a4a347a40124a7da631878872dc6356dc6751a5c278312d35778a03e0a7be31b972e869a3f792e955a1a752b6eedb1101ffabf079be1dbd4b881cbcf41ae54656df041021801fac82877f11005f2c5ce412d7ff338661178092c35276bca0507deee1503a8b7661336cabd74d988db4e3e5f55b2ad1688576ac5cd3bbda07cb3124e7910de66312fe6bdd1dc4a242a92423515954ec5eeab0a4e6f002f07036027ff291f5069d77e36f8c418b53db55a7d4966174b7f555faff97d9fca8afce04e17555bac965f7a1289a3b0b38b2031597345f4aa7df693bf836e02770a2fe49e4788cb46c940da327583764f4928f85bc67183759465b528b7206f895771e6d388f5fad692b5350372afdfb7e9f6ef0b88e107e1baf21764666adfe08e9e690aadd4d336774b857bc21965d90c18a65974ac40be75ea3a239e7a1c2a84894d4b580af3bc40c44ff147de365ba3ec14adc2f946dae9fbffca82db4a3f6cd7d443eff50c014c4d9cf2cb3f297324c0b02f7bc48241e15cb1fdd209ca6005a903558406552cf1d85ba141dc329b4f45e7ed614efd90ee67bdc199d637af7a7cab6d32b4ae804a0dcaa2beffe623cbb55cd93deb68acb7883b7462eda0a07344e0bb39349466e8a765d77416708cf022599196dba9464b9058c2305325f12fbbf4f7e6aca5fc43c4449598ca3677dc32b2fd51e626d490f010fbd1f97fcc776e85508164f8b9aed1979d81d8d5ad5d97e3d955b4666c4ca54a43b1ac0db62da1d384565675475e0adffef806b9e510ddf965bf2a0ba4b67c3aad491c2b7c613459a1822a15ca12af70df96fbde4e373adecc122213cd65a857354d3b60b1f986e8f3284e9f5153383e5b9d65e69696396446654ae8a3d1e5636631140f562c2f9696ca906813a77374b37d718dab9453687666256fcbd3baa1531357d602426859615e873fb5452465f9b8582f2b66c5d691c3ddc11f8281d12573fa0151c01462f9866c24444e58efc61670f388a862721489f98831bc20c2dc5004342bd8a0f8445c34fcee0aa7aa9515ea04f1ab06323be72236a04889a57e6f1ebf19c6591ee936ec218ec7d41f57a87b5dbcd0d4732e69433605c0fb6ea5adbd971b540e27d0ad7f84645115959236c66df8f7ca9a552bec341e309e70d437f48315e0e10b4ba8be6a1d91c9b81462d41fd7cab3ca305e53d6d00066ef74c5757a70de670b510b9208c114a58f7f31bf58b73e9ef0c6ab50f2f7d6df3fe02812a66e1ac094abdc01ecd9c67a4d3c6d9796d47f3484fc7c378cf3bdf7d75a5668b668d588c2e910d808e56b767d43399d114066520416b723cd434f1d65a1683a561f53ab68392ae867b1074bbcb2ec35f983a7e2b82011ae70553cfa065498ab1d655bf8f6e6fd0d60f997cf8a2f8e540726e73f56c98706e190e0809788545014d1498d9a64345a4d7893fc563283905f53a007a90bd1654af426bbdb569803093db0b857434aad3de7bc949cd3843881c140af59ef44ee580364b06abbf594eba7bb2b8680954b0a14606690eeb83e9ea61bb650955f60bc9dfd38bf3e0659eb9725272128a238fd6167fc2a3caf56354ff0fcdee557daf9f4eeb3845a9f9c69be7de0f35c328d32b2fa5c3bdd093e24f73bcbd16386fdb952610360b5c86febd9325572b634a8f7d913ac591fa72cb1c46800f1cf237c3b1d26cb3c67d91e8a94e650d8b42cc59eb10d5e7614cd204c7fcd19fe406558fcb7bcdcc695bb996c6af1a2794365fb760b9174b23f5257d04739ffefcb02c4957512c52a555f06669f5d64bf6dd08b363c02774efd27e5144d4d9b8be56eea8c4bca3eaf930b3d7e02f02ff70c4053628e34c5cc21cba663ed77e32f0445866c5c77c58f151d5cdc4051dbe9ed28ee4d31ec660e38b61b5aa70228d6b6cb32d3f2b073a325a048bf4d862fe72687970bd54900d08a437a28963abe6f817b1f5ccd6c61e5f8711bc5c95932f75505307ef4f0d782768bdb9d1aff8a6f1388cea0afc5136442dabfca72e0675a606bec2b158ff69d6ed5309a76c8e492bbfc1f4f7800a70b414848f6ea8ac696c93610df4c3a543b9e91c802f06ed874114b1b4fae1511e0c9cd6db19be77771ec580c42f75a6f688568a9f1ddfea2a5534a59b16b4dfd8d4c1bae58363a823b6b3991345683dc0753aea1221526cbcfa4ad25f66b19f9c1de4939c538cdb60930a45c0f35a76e63123fcdb14c557f98ac27eacc0c3f451f415f5a47640f28c4cb39cf568ff7fd0fa7824dc0a100694b3c66ea01116c3873449a8217774a1a512555294afe62b2382b6a3cfa2f5d7b13ab69f52959a3fdf480762fefa478e68b4368568ef0a902ace7b281320c093d1b00d7c2dadd36baac9401c1ccec943ed8e032cfa8fbce308d03b08ff4dc82687bde107ad00995999eaad094f9ec5b14dce0b60c4263844a036c37a9d46e59b71f48f1fbb2d7ad9189eeaf797857da928c2bada2b5459e5a3effd0f6049012253b7dd845a52b163901ac6746c85a463e115ea49dc8cd2e41740f3f32c68469131b0052228605bbb6bcd2d1f0e0b4263f3d7b3df32c65c3dab063b1050d423e345303bf3478a5f68de907ea50b497ae52e1b553c622cc31ad4e4215d1f8570b558edd254523dd2929ae80278d155637f414e6690a3d2eaca433d854aa4d9ac83ea1cc46612d92ffc86b3471a5b48e2729427564388f14341bdbfb92febb537a3f5696ed93eb33e0b4dee54c53d1ec2702e6b8713b09f80604cce72f98744ca773f2fbe71f6e8d7fb3d1d331b8ce852977ac743772a4911b0d5b4755f235d7860d53db7463c1301e4e333e80b03640954ddd7aacaf87e3799710ebfdfc08aa45656a9087f5a3cb977e3dc1f19f43e5a6146f5637878ecf89d8c28af76e80fbe06d8c12d36e9be75374c44de67d526e5583d9fce23e3af143bbe234c2632e271e12e1e22688499d2deff55ca812229f8eb92de6240a9eab48e56b3d276c03256660b0fb6cc535f6ec946c6ef3dc5c837eac3e1cd2c23b36dc3a5c4f4294075867f719a82d97156f1ce084eee98ec2f8611497e91d75aa5299136e31970c79421cec68fa4e0e9e479549c9aabd44a6cbae1fe1dc00a654bbede265c8afe333453e883dce41835ed77f49a2f578f3cafd79c1104f71ac52e320cdefaaca63ecb2e46f35b448694e469c22325bd9414","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d899eba0ef61fc89b4578090295e1ef0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
